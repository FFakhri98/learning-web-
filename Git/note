از Zsh برای ترمینال گیت استفاده می کنم.


git init
git init path_of_the_directory
با این دو دستور میتوانیم یک directory را به repository تبدیل کنیم و بعد از وارد کردن این دستور یک فولدر git. ساخته می شود که در اوبونتو چون اسمش با نقطه شروع شده پنهان است و برای آشکار شدنش میتوان از ctrl+h استفاده کرد و یا در ترمینال دستور ls -a رو زد.


git clone --branch=branch_name --depth=number_of_commit the_http_address  
حتی می توانیم یک ریپازیتوری که روی سیستم خودمان هست را در آدرس دیگری از سیستم خودمان clone کنیم. یعنی به جای the_http_address میتونیم آدرس اون ریپازیتوری روی سیستم را بزنیم. از اونی که clone شده هم باز میشه clone کرد.


برای هر ریپازیتوری باید اسم و ایمیل خودمون رو وارد کنیم.
git config --global user.name "fahimeh"
git config --global user.email "fahimeh@gmail.com"
وقتی global-- را استفاده می کنیم برای تمام ریپازیتوری های همان کاربر لینوکس لحاظ می شود. به جای آن می شود از local-- استفاده کرد.


***commit message is SOooOOOoOoO... important!***
این توضیح تنها چیزی است که از لیست پشت سر هم تغییرات میبینیم پس هرچه informative تر باشه بهتره. تایپ کار رو بگیم و بگیم کجا بوده و ... . باید حسابی reperesentive باشه.


فایل متنی gitignore.
یه بخشی از پروژه هست که نمی خوایم به عنوان پروژه شناخته بشه و می خوایم گیت اونها رو نادیده بگیره در این حد که حتی تو track files هم نیاد و نشونش نده. مثلا اگر فایل متنی gitignor. رو ایجاد کنیم و توش بنویسیم log.* هر فایلی که با log. تموم میشه رو گیت نادیده میگیره.


ممکنه مثلا یه سری چیزا رو تغییر بدیم. ولی هنوز کامیت نکرده باشیم و یه سری تغییر دیگه بخوایم انجام بدیم و تغییر قبلی ها رو هم نخوایم از بین ببریم.
git stash
فایل هایی که در staging area هستند رو میبره به یه جای دیگه و برای دیدن اون تغییرات و فایل ها می توانیم از دستور های زیر استفاده کنیم.
git stash show
git stash pop stash@\{\}
برای بیرون آوردن تغییرات از حالت stash از دستور زیر می توان استفاده کرد.
git stash pop 
برای بیرون آوردن یکی از تغییراتی که در حالت stash هست می توان از دستور زیر استفاده کرد که عدد رو می توان از دستور {\}\@git stash pop stash استفاده کرد.
git stash pop stash@\{number_of_that_stash\}
دستور زیر حتی untrached files رو هم به stash اضافه می کنه.
git stash -u
دستور زیر حتی فایل های ignored را هم که به خاطر gitignore. به این شکل دراومدن رو هم به stash اضافه میکنه.
git stash -a


git diff
git diff HEAD
برای اینکه ببینیم نسبت به آخرین کامیت کجای فایل تغییر کرده و چه تغییری کرده. و این دو دستور بالا هر دو یک کار را انجام می دهند.
git dif the_name_of_some_commit
با این دستور دیگه نسبت به یکی از کامیت های قبل از HEAD میتونیم مقایسه کنیم.
git diff HEAD^
یا
git diff HEAD^ HEAD
نسبت به یه کامیت قبل از HEAD
git diff HEAD^^
یا
git diff HEAD^^ HEAD
نسبت به دو کامیت قبل از HEAD
git diff HEAD~3
یا
git diff HEAD~3 HEAD
نسبت به سه کامیت قبل از HEAD
git diff HEAD~5 name_of_some_file
همچنین می توانیم مشخص کنیم که تنها تغییرات یکی از فایل ها را نشان بدهد.


git log 
هش (hash)کامیت ها و کامیت مسج ها و مشخصات نویسنده کامیت ها و تاریخ تغییر رو نشون میده.
git log --oneline
کوتاه تر و یک خطی نشون میده و هش کامیت ها رو هم کوتاه و تنها هشت کاراکتر اولش رو نشون میده.
git log --oneline --graph
حتی گراف برای branch های دیگه رو هم نشون میده.
کلا این دستور رو خیلی میشه customize کرد و حتما قابلیت های دیگرش رو هم نگاه کن.


git blame the_name_of_some_file
میتونیم با این دستور ببینیم هر خطی توسط چه کسی و در کدوم کامیت اضافه شده است.


git tag
برای راحت تر بررسی شدن تغییرات می توانیم به کامیت ها tag نسبت بدیم. این دستور بالا همه tag های پروژه رو نشون میده.
git tag "V1.0"
تگ رو برای کامیتی که الان روش هستیم در نظر میگیره یعنی برای HEAD . میشه تگ رو به جای هش کامیت استفاده کرد.
git tag V0.8 the_hash_of_that_commit
میتوانیم چند کاراکتر اول هش رو هم بنویسیم.


git reflog
تمامی تغییرات آن ریپازیتوری را نشان می دهد.


بازگردانی تغییرات و بازنویسی تاریخچه.
git commit --amend
آخرین کامیتی که نوشته ایم را می خواهیم با دستور بالا تغییر دهیم.یعنی اگر این دستور بالا رو بزنیم تغییراتی که هنوز کامیت نکرده ایم به تغییراتی که آخرین بار اضافه می شوند و همچنین میتوانیم متن کامیت آخر را هم علاوه بر اضافه کردن تغییرات جدید به آخرین کامیت با دستور زیر تغییر دهیم.
git commit --amend -m "new commit message"
در یک پروژه تیمی هیچوقت نباید این تغییر را روی کامیت یه نفر دیگه انجام دهیم.


git clean
اگر در ادامه دستور n- بذاریم بهمون میگه این دستور قراره چیکار کنه : git clean -n

# توضیحی درباره ی این دش کوچولو ها :
فایل های آشکار رو به صورت لیست نشون میده :‌ls -l
فایل های پنهان رو هم نشون میده : ls -a
فایل های پنهان و آشکار رو به صورت لیست نشون میده : ls -l -a یا ls -la

git clean -n -d یا git clean -nd 
این دو دستور بالا در مورد git clean توضیح می دهند که چه کاری انجام می دهد و همینطور با اضافه کردن d- توضیح در مورد directory ها را هم می دهد که در غیر اینصورت نمی داد.
git clean -f -d  یا git clean -fd
به صورت force تغییراتی که اعمال کردیم و هنوز کامیت نکرده ایم را حذف میکند.
git clean -i -d یا git clean -id
به صورت intractive تغییراتی که اعمال کرده ایم را حذف میکند. یعنی قبل از حذف کردن ازمون می پرسه که می خوای حذف کنم یا نه؟
git clean -x
با این دستور می توانیم فایل های نوشته شده در gitignore. را هم حذف کنیم.


تغییراتی که در کامیت قبلی داده ایم را برعکس میکند. 
git revert the_hash_of_that_commit


با این دستور تاریخچه هم تغییر می کند. 
git reset --hard HEAD~2
یعنی دو تا کامیت آخر رو حذف می کنه.
git reset --soft HEAD~2
دوتا کامیت آخر رو حذف نمی کنه ولی جای HEAD عوض میشه و میره رو دو تا کامیت قبلی.



git rm
هم فایل را حذف می کنه و هم از تاریخچه پاکش می کنه.


git remote add origin ssh_address
میتوانیم برای ریپازیتوری که داریم یک origin ایجاد کنیم.


git push origin master
کامیت ها رو می خوایم بفرستیم به سرور و هم میگیم کدوم ریموت و هم میگیم کدوم branch.


git fetch origin master
مثل دستور git pull است ولی HAED رو تغییر نمیده.


کار گروهی روی گیت :


برای اینکه ببینیم چه branchهایی داریم : git branch
برای اینکه یه branch جدید بسازیم و به اون branch منتقل بشیم: git checkout -b new-branch
برای اینکه موقع فرستادن تغییرات به گیت هاب branch تازه ساخته شده را هم به گیت هاب منتقل کنیم : git push -u origin new-branch
برای رفتن به branchای که قبلا ساخته شده و وجود دارد : git checkout branch-name




















































